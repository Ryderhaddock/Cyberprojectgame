<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSINT Auditor Canvas Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles using Tailwind */
        body {
            /* IMPORTANT: Add tabindex to ensure the body can receive focus for key presses */
            tabindex: 0;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Start from top */
            align-items: stretch; /* Stretch to full width */
            height: 100vh; /* Full viewport height */
            width: 100vw;  /* Full viewport width */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            /* UPGRADE 5: Dark Mode Background */
            background-color: #0f172a; 
            color: #e2e8f0;
        }

        /* UPGRADE 1: Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: #0f172a;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 5000;
            font-size: 1.5em;
            transition: opacity 0.7s ease-out;
        }

        .loader-bar {
            width: 260px;
            height: 6px;
            margin-top: 25px;
            background: rgba(255,255,255,0.15);
            overflow: hidden;
            border-radius: 6px;
            position: relative;
        }

        .loader-bar::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 60%;
            height: 100%;
            background: #3b82f6;
            animation: loading 1.6s infinite;
            border-radius: 6px;
        }

        @keyframes loading {
            0% { transform: translateX(-150%); }
            100% { transform: translateX(250%); }
        }

        /* --- Top Bar --- */
        #top-bar {
            width: 100%;
            flex: 0 0 auto; /* Fixed height, don't grow/shrink */
            padding: 8px 15px; /* Slightly tighter padding */
            background-color: #1e293b; 
            border-bottom: 4px solid #1e3a8a;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            z-index: 20;
        }

        #suspicion-panel {
            text-align: left;
            font-size: 0.85em;
            color: #e2e8f0;
            max-width: 1200px;
            margin: 0 auto;
        }

        #suspicion-bar-container {
            height: 14px;
            background-color: #334155;
            border-radius: 7px;
            overflow: hidden;
            margin-top: 4px;
            border: 1px solid #475569;
        }

        #suspicion-bar {
            height: 100%;
            width: 0%;
            background-color: #10b981; 
            transition: width 0.3s, background-color 0.3s;
        }


        /* --- Canvas Container --- */
        #game-container {
            width: 100%;
            flex: 1 1 auto; /* Fill remaining vertical space */
            background-color: #d1fae5; 
            position: relative;
            overflow: hidden;
            /* Removed border/rounding to fit flush */
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5); /* Inner shadow for depth */
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- Dialogue Box Styling --- */
        #dialogue-box {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            /* REDUCED HEIGHT for more playable room */
            min-height: 110px; 
            background-color: rgba(255, 255, 255, 0.95);
            border-top: 4px solid #1e3a8a;
            padding: 10px 15px;
            box-sizing: border-box;
            font-size: 1em;
            color: #1f2937;
            backdrop-filter: blur(4px);
            z-index: 10; /* Ensure above canvas content */
        }

        #dialogue-text {
            margin-bottom: 8px;
            font-weight: 500;
            min-height: 30px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        #choice-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        #choice-buttons button {
            padding: 8px 16px;
            font-size: 0.95em;
            cursor: pointer;
            background-color: #3b82f6;
            color: white;
            border: 2px solid #1e3a8a;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 3px #1e3a8a;
        }

        #choice-buttons button:hover {
            background-color: #2563eb;
            transform: translateY(1px);
            box-shadow: 0 2px #1e3a8a;
        }

        #choice-buttons button:active {
            transform: translateY(3px);
            box-shadow: 0 0 #1e3a8a;
        }

        #audit-button {
            background-color: #ef4444;
            box-shadow: 0 3px #b91c1c;
        }

        .speaker-name-tag {
            font-weight: 700;
            padding: 2px 6px;
            font-size: 0.9em;
            border-radius: 4px;
            margin-right: 8px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            display: inline-block;
        }

        /* --- Control Panel & Tracker --- */
        #control-panel {
            width: 100%;
            flex: 0 0 auto; /* Fixed height at bottom */
            background-color: #1e293b; /* Darker Slate */
            border-top: 4px solid #1e3a8a;
            padding: 12px;
            display: flex; /* Flex row to center content */
            justify-content: center;
            gap: 20px;
            align-items: center;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.3);
            color: #e2e8f0;
            z-index: 20;
        }

        .panel-content {
            display: grid;
            grid-template-columns: 2fr 1.5fr;
            gap: 15px;
            width: 100%;
            max-width: 1200px; /* Constrain width on large screens */
        }

        #tracker {
            background: #334155;
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid #475569;
            font-size: 0.85em;
            text-align: left;
            color: #e2e8f0;
        }
        #tracker p { margin: 2px 0; font-weight: 500; }
        .missing { color: #94a3b8; }

        .collected { color: #34d399; font-weight: bold; text-shadow: 0 0 10px rgba(52, 211, 153, 0.3); } 
        
        .hint-text { color: #fbbf24; font-style: italic; margin-top: 5px; border-top: 1px solid #475569; padding-top: 4px; }

        #password-box {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }

        .login-field {
            display: grid;
            grid-template-columns: 95px 1fr;
            align-items: center;
            gap: 5px;
        }
        .login-field label {
            width: 95px;
            font-weight: 600;
            text-align: right;
            white-space: nowrap;
            padding-right: 5px;
            color: #cbd5e1;
        }

        /* UPDATED: type="text" for visibility */
        #username-input, #password-input {
            padding: 6px;
            border: 1px solid #475569;
            border-radius: 4px;
            font-size: 0.95em;
            width: 100%;
            background-color: #0f172a;
            color: #f8fafc;
        }
        #username-input {
            background-color: #1e293b;
            color: #94a3b8;
        }
        
        #login-button {
            padding: 6px;
        }

        /* --- Modal/Pop-up Styling --- */
        #info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            /* UPDATED: Align to top with padding to prevent cutoff */
            align-items: flex-start;
            padding-top: 60px;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        #modal-content {
            background-color: #f8fafc;
            padding: 30px;
            border: 4px solid #1e3a8a;
            border-radius: 12px;
            width: 90%;
            max-width: 600px; /* Increased max width for more content */
            text-align: center;
            position: relative;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            color: #1e293b;
            /* Ensure content can scroll if still too tall on small screens */
            max-height: 85vh;
            overflow-y: auto;
        }
        #modal-content h3 {
            font-size: 1.25em;
            font-weight: 700;
            margin-top: 15px;
            color: #1e3a8a;
        }

        #modal-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #1e3a8a;
            font-weight: bold;
        }
        .hidden { display: none !important; }

        /* --- Title Screen --- */
        #title-screen, #briefing-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0f172a;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            background-image: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }

        #title-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #3b82f6;
            text-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            animation: pulse-title 3s infinite ease-in-out;
        }

        @keyframes pulse-title {
            0%, 100% { transform: scale(1); text-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
            50% { transform: scale(1.02); text-shadow: 0 0 30px rgba(59, 130, 246, 0.8); }
        }

        #title-screen button, #briefing-screen button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        #title-screen button:hover, #briefing-screen button:hover {
            background-color: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        #briefing-content {
            background-color: #1e293b;
            padding: 40px;
            border-radius: 12px;
            border: 2px solid #3b82f6;
            max-width: 500px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        #briefing-content h2 {
            font-size: 2em;
            margin-bottom: 15px;
            color: #f59e0b;
        }
        #briefing-content p {
            margin-bottom: 25px;
            line-height: 1.6;
            color: #cbd5e1;
        }

        /* Game Over Specific Style */
        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(5px);
        }
        #game-over-modal #modal-content {
            border-color: #ef4444;
            background-color: #fef2f2;
        }
        #game-over-modal #modal-title {
            color: #ef4444;
        }
        
        /* Final Screen Specific Style */
        #final-screen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(5px);
        }
        #final-screen-modal #modal-content {
            border-color: #10b981;
            background-color: #f0fff4; /* Light Green background */
        }
        #final-title {
            color: #10b981 !important;
        }
    </style>
</head>
<body tabindex="0">

    <!-- UPGRADE 1: Loading Screen -->
    <div id="loading-screen">
        <h1 class="text-2xl font-bold text-blue-400 mb-4">Initializing System...</h1>
        <div class="loader-bar"></div>
        <p class="text-sm text-slate-500 mt-2">Loading Assets & Security Protocols</p>
    </div>

    <!-- Title Screen -->
    <div id="title-screen">
        <h1>OSINT Auditor: The Park Infiltration</h1>
        <p class="mb-8 text-lg text-slate-300">Gather public information to demonstrate a critical security vulnerability.</p>
        <button onclick="showBriefing()">START AUDIT</button>
    </div>

    <!-- Briefing Screen (Hidden initially) -->
    <div id="briefing-screen" class="hidden">
        <div id="briefing-content">
            <h2 class="text-3xl text-red-400 mb-6">Your mission...</h2>
            <h2>MISSION BRIEFING</h2>
            <p>Your target is the **Orange person**, who represents the CEO. Your goal is to gather three pieces of public information that could be used as security answers or components of a weak master password.</p>
            <p class="font-bold text-xl text-yellow-300">Goal: Find three key password components.</p>
            <p class="text-sm italic mt-5 text-slate-400">Use WASD or Arrow Keys to move. Interact by touching the people.</p>
            <button onclick="startGame()">BEGIN</button>
        </div>
    </div>

    <!-- TOP SUSPICION BAR -->
    <div id="top-bar">
        <div id="suspicion-panel">
            <p class="font-bold text-slate-300">SUSPICION METER</p>
            <div id="suspicion-bar-container">
                <div id="suspicion-bar"></div>
            </div>
        </div>
    </div>
    <!-- END TOP SUSPICION BAR -->

    <div id="game-container">
        <!-- Canvas for the game world -->
        <canvas id="game-canvas"></canvas>

        <!-- Dialogue Box (RPG Vibe) -->
        <div id="dialogue-box">
            <p id="dialogue-text">
                <span id="speaker-name" class="speaker-name-tag" style="background-color: #94a3b8; display: none;">SPEAKER</span>
                <!-- Content is initialized in JS now -->
                <span id="dialogue-content"></span>
            </p>
            <div id="choice-buttons">
                <!-- Audit button appears here when complete -->
            </div>
        </div>
    </div>

    <!-- Control Panel Below Game Screen -->
    <div id="control-panel">
        <div class="panel-content">
            <!-- Info Tracker (Progress Box) -->
            <div id="tracker">
                <p id="tracker-title" class="text-slate-400 mb-2 text-xs uppercase tracking-wider">Intel Collected:</p>
                <!-- These are updated dynamically -->
                <p id="track-pet-name" class="missing">1.) ???</p>
                <p id="track-founding-year" class="missing">2.) ???</p>
                <p id="track-mascot" class="missing">3.) ???</p>
                <div id="password-hint" class="hidden hint-text"></div>
            </div>

            <!-- Password Slot -->
            <div id="password-box">
                <div class="login-field">
                    <label>USERNAME:</label>
                    <input type="text" id="username-input" value="ADMIN" readonly>
                </div>
                <div class="login-field">
                    <label for="password-input">PASSWORD:</label>
                    <!-- UPDATED: type="text" -->
                    <input type="text" id="password-input" placeholder="Enter Password" onkeydown="if (event.key === 'Enter') checkPassword()">
                </div>
                <button id="login-button" onclick="checkPassword()"></button>
            </div>
        </div>
    </div>

    <!-- Educational Pop-up Modal -->
    <div id="info-modal" class="hidden">
        <div id="modal-content">
            <!-- Close button added here -->
            <button id="modal-close-button" onclick="continueGame()">×</button>
            <h2 id="modal-title" class="text-2xl font-bold mb-4"></h2>
            <p id="modal-concept" class="font-semibold mb-2"></p>
            <div id="final-report" class="hidden text-left">
                <!-- Vulnerability Report & Fix Recommendations are added here -->
            </div>
            <p id="modal-explanation" class="text-slate-600"></p>
            <button onclick="continueGame()" class="mt-6 bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700">Acknowledge & Continue</button>
        </div>
    </div>

    <!-- Game Over Specific Modal -->
    <div id="game-over-modal" class="hidden">
        <div id="modal-content">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">AUDIT FAILED: GAME OVER</h2>
            <p id="modal-concept" class="font-bold text-red-600 mb-4">You were caught by security.</p>
            <p id="modal-explanation">Security awareness is key in OSINT. Too much suspicion led to failure. Refresh the page to start a new audit.</p>
        </div>
    </div>
    
    <!-- NEW: Final Screen Specific Modal -->
    <div id="final-screen-modal" class="hidden">
        <div id="modal-content">
            <h2 id="final-title" class="text-3xl font-bold mb-4">AUDIT COMPLETE!</h2>
            <p id="final-message" class="font-bold text-slate-700 mb-6">Congratulations, Auditor! You have successfully completed the OSINT infiltration simulation.</p>
            <p class="text-slate-600 mb-8">You successfully identified the critical vulnerability and demonstrated the power of Open-Source Intelligence and social engineering principles. Your mission is complete.</p>
            <button onclick="window.location.reload()" class="mt-6 bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700">Start New Audit</button>
        </div>
    </div>

    <script>
        // --- Canvas Polyfill ---
        if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, radius) {
                if (typeof radius === 'number') radius = [radius, radius, radius, radius];
                else if (!Array.isArray(radius) || radius.length !== 4) radius = [0, 0, 0, 0];
                this.beginPath();
                this.moveTo(x + radius[0], y);
                this.lineTo(x + w - radius[1], y);
                this.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
                this.lineTo(x + w, y + h - radius[2]);
                this.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
                this.lineTo(x + radius[3], y + h);
                this.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
                this.lineTo(x, y + radius[0]);
                this.arcTo(x, y, x + radius[0], y, radius[0]);
                this.closePath();
                return this;
            };
        }

        // --- Canvas Setup ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        
        // Variables to hold dynamic dimensions
        let GAME_WIDTH = 800;
        let GAME_HEIGHT = 600;
        let PLAYABLE_AREA_BOTTOM = 450;

        // --- Game State ---
        const FACTS_REQUIRED = 3;
        const TARGET_PASSWORD = "Sparky2008Buster"; // UPDATED PASSWORD

        const IDLE_DIALOGUE = "";

        // UPGRADE: Smaller characters
        const playerRadius = 13; 
        const npcRadius = 13;   
        
        const playerSpeed = 150;
        const npcWanderSpeed = 30;

        let collectedFacts = {};
        let gameHints = {};
        let suspicion = 0;
        let loginAttempts = 3;
        let gameActive = false;
        let interactionActive = false;
        let canInteract = true;
        let isModalVisible = false;
        let typingInterval; 

        const INTERACTION_COOLDOWN = 1200;

        let keysPressed = {};
        let lastTime = 0;
        let activeNPCKey = null;

        // NEW: Educational Content Data (Expanded for depth)
        const educationalContent = [
            { 
                title: "OSINT Core Concept: Social Engineering", 
                concept: "The Art of Human Hacking", 
                body: "In this scenario, approaching the CEO's wife and friendly employees was a form of **Social Engineering**, specifically using **Pretexting** (creating a false, innocent scenario, like small talk) to manipulate targets into divulging non-public information. This bypasses technical security by exploiting human trust. "
            },
            { 
                title: "OSINT Technique: Data Aggregation & Correlation", 
                concept: "The 'Needle' in the Haystack", 
                body: "No single fact (pet name, year, mascot) was a security risk alone. The risk emerged when you **aggregated** these pieces and **correlated** them, revealing the CEO's predictable password structure. Attackers routinely combine data from LinkedIn, public records, and social media to form complex guesses."
            },
            { 
                title: "OSINT Practice: Passive vs. Active Reconnaissance", 
                concept: "Low Risk vs. High Risk", 
                body: "Moving around and checking the monument was **Passive Reconnaissance** (low risk). Asking detailed, sensitive questions to the Pink or Amber NPCs was **Active Reconnaissance**. Active steps raise suspicion because they probe deeply and directly for internal secrets, increasing the chance of being detected or shut down."
            },
            { 
                title: "Cybersecurity Takeaway: Fix Recommendations", 
                concept: "Securing Against OSINT Breaches", 
                body: "The vulnerability demonstrated here is common. The fixes include: 1. Enforcing password complexity (minimum length, mixed characters). 2. Implementing **Multi-Factor Authentication (MFA)**, which would require a second login credential (e.g., a phone code) even if the password was guessed. 3. Training employees to recognize and resist social engineering tactics."
            }
        ];
        let currentEduIndex = 0;

        // Buffer Canvas for Static Background
        const backgroundCanvas = document.createElement('canvas');
        const backgroundCtx = backgroundCanvas.getContext('2d');

        // --- DOM Elements ---
        const titleScreen = document.getElementById('title-screen');
        const briefingScreen = document.getElementById('briefing-screen');
        const speakerNameEl = document.getElementById('speaker-name');
        const dialogueContentEl = document.getElementById('dialogue-content');
        const choiceButtons = document.getElementById('choice-buttons');
        const infoModal = document.getElementById('info-modal');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScreenModal = document.getElementById('final-screen-modal'); // NEW
        const modalTitle = document.getElementById('modal-title');
        const modalConcept = document.getElementById('modal-concept');
        const modalExplanation = document.getElementById('modal-explanation');
        const finalReportSection = document.getElementById('final-report');
        const passwordInput = document.getElementById('password-input');
        const suspicionBar = document.getElementById('suspicion-bar');
        const loginButton = document.getElementById('login-button');
        const passwordHintEl = document.getElementById('password-hint'); 

        const trackerElements = {
            'pet_name': document.getElementById('track-pet-name'),
            'founding_year': document.getElementById('track-founding-year'),
            'mascot_name': document.getElementById('track-mascot')
        };

        const factDefinitions = {
            'pet_name': "CEO's Pet Name",
            'founding_year': "Founding Year",
            'mascot_name': "Company Mascot"
        };

        // --- Game Objects ---
        let player = { x: 400, y: 100 }; // Initial placeholder
        
        // Scenery definitions will be set on resize
        let scenery = [];

        const initialNPCMovement = () => ({
            vx: (Math.random() * 2 - 1) * npcWanderSpeed,
            vy: (Math.random() * 2 - 1) * npcWanderSpeed,
            moveTimer: 2 + Math.random() * 3
        });

        const npcsData = {
            'Purple': { x: 80, y: 150, color: '#7c3aed', dialogue: "Hello! I'm the CEO's wife. We love our dog so much we put him in everything... especially those silly security questions and passwords!", choices: [{ text: "A: Engage in small talk about the dog.", secure: true, action: 'purple_step2', risk: -5 }], ...initialNPCMovement() },
            'Orange (CEO)': { 
                x: 550, y: 380, color: '#f59e0b', 
                dialogue: "It's a wonderful day for a company picnic, isn't it? Very relaxing!", 
                choices: [
                    { text: "A: Agree and move on.", secure: true, risk: -5 },
                    { text: "B: Ask for his login credentials directly.", secure: false, risk: 80 } 
                ], 
                ...initialNPCMovement() 
            },
            'Green': { x: 560, y: 150, color: '#10b981', dialogue: "Did you see the guy dressed as Buster the Beaver? He's the best mascot we've ever had!", choices: [{ text: "A: Jot down the mascot's name.", secure: true, info: { key: 'mascot_name', name: "Buster the Beaver" } }], ...initialNPCMovement() },
            'Violet': { 
                x: 120, y: 400, color: '#8b5cf6', 
                dialogue: "This lemonade is too sweet, I prefer water. You?", 
                choices: [
                    { text: "A: Mention you prefer the free snacks.", secure: true, risk: -2 },
                    { text: "B: Ask if the security cameras cover this area.", secure: false, risk: 25 } 
                ], 
                ...initialNPCMovement() 
            },
            'Pink': { 
                x: 200, y: 200, color: '#f472b6', 
                dialogue: "I’m in HR. Everyone is so relaxed today, even the CEO!", 
                choices: [
                    { text: "A: Ask about a specific colleague’s whereabouts.", secure: false, risk: 20 }, 
                    { text: "B: Discuss the good music.", secure: true, risk: -5 },
                    { text: "C: Ask for a list of employee emails.", secure: false, risk: 50 } 
                ], 
                ...initialNPCMovement() 
            },
            // UPDATED GRAY DIALOGUE
            'Gray': { x: 50, y: 350, color: '#94a3b8', dialogue: "I was wandering near the trees earlier. Did you notice that old stone monument in the northeast? It has some dates carved on it.", choices: [{ text: "A: Thanks for the tip.", secure: true, risk: -2 }], ...initialNPCMovement() },
            'Magenta': { 
                dialogue: "I think I saw the CEO head toward the cake table. I heard he loves vanilla.", x: 640, y: 280, color: '#d946ef', 
                choices: [
                    { text: "A: Agree and move on.", secure: true, risk: -2 },
                    { text: "B: Ask if he keeps his laptop with him.", secure: false, risk: 35 } 
                ], 
                ...initialNPCMovement() 
            },
            'Cyan': { isHint: true, dialogue: "I heard the boss uses his company's founding year in all his security passwords. Says it's easy to remember.", choices: [{ text: "A: Jot down the tip.", secure: true, action: 'cyan_hint', info: { key: 'uses_year_in_password', name: "Founding Year Hint" }, risk: -2 }], ...initialNPCMovement() },
            'Lime': { dialogue: "I heard there's a rumor about a huge new product launch soon.", x: 700, y: 500, color: '#84cc16', choices: [{ text: "A: Ask for details.", secure: false, risk: 30 }, { text: "B: Smile and walk away.", secure: true, risk: -5 }], ...initialNPCMovement() },
            'Amber': { 
                dialogue: "I parked about a mile away. Worth the walk though!", x: 720, y: 180, color: '#fbbf24', 
                choices: [
                    { text: "A: Nod and move on.", secure: true, risk: -2 },
                    { text: "B: Ask to borrow their badge to get back in.", secure: false, risk: 40 } 
                ], 
                ...initialNPCMovement() 
            },
            'Yellow': { x: 600, y: 40, color: '#fde047', dialogue: "I swear the CEO is obsessed with the company mascot, he puts it in everything!", choices: [{ text: "A: Acknowledge the comment.", secure: true, action: 'yellow_hint', info: { key: 'uses_mascot_in_password', name: "Mascot Hint" }, risk: -2 }], ...initialNPCMovement() },
            // UPDATED: Guard choices for Game Over on "No"
            'Blue Guard 1': { x: 350, y: 50, color: '#3b82f6', isGuard: true, dialogue: "Guard: Welcome to the company picnic. Are you an employee of the firm?", choices: [{ text: "Yes, I am.", secure: true, action: 'guard_pass' }, { text: "No, I'm just visiting.", secure: false, action: 'guard_fail_kickout' }] },
            'Blue Guard 2': { x: 450, y: 50, color: '#3b82f6', isGuard: true, dialogue: "Guard: Hello! Are you enjoying the event? Are you staff?", choices: [{ text: "Yes, I'm staff.", secure: true, action: 'guard_pass' }, { text: "Just visiting a friend.", secure: false, action: 'guard_fail_kickout' }] }
        };

        // Add Props Data
        const propsData = {
            'Monument': {
                x: 700, y: 80, width: 50, height: 40, color: '#64748b',
                dialogue: "A stone monument dedicated to the company's founding. The date '20..' is visible, but the last two digits are worn away.",
                choices: [{ text: "Examine closely.", action: 'monument_hint', secure: true, risk: 0 }]
            }
        };

        // --- Audio & Logic ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency, duration, volume = 0.5) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            oscillator.stop(audioContext.currentTime + duration);
        }
        function playClick() { playSound(440, 0.05, 0.2); }
        function playSuccess() { playSound(660, 0.1, 0.4); playSound(880, 0.2, 0.4); }
        function playWarning() { playSound(100, 0.5, 0.6); }

        function updateSuspicion(riskChange) {
            suspicion = Math.max(0, Math.min(100, suspicion + riskChange));
            suspicionBar.style.width = `${suspicion}%`;
            if (suspicion >= 90) {
                suspicionBar.style.backgroundColor = '#ef4444';
                if (riskChange > 0) playWarning();
            } else if (suspicion >= 50) {
                suspicionBar.style.backgroundColor = '#f59e0b';
            } else {
                suspicionBar.style.backgroundColor = '#10b981';
            }
            if (suspicion >= 100) triggerGameOver("Your extreme behavior drew too much attention.");
        }

        function typeText(element, text, speed = 25) {
            element.textContent = "";
            if (typingInterval) clearInterval(typingInterval);
            let i = 0;
            typingInterval = setInterval(() => {
                element.textContent += text[i];
                i++;
                if (i >= text.length) clearInterval(typingInterval);
            }, speed);
        }

        function showBriefing() {
            titleScreen.classList.add('hidden');
            briefingScreen.classList.remove('hidden');
        }

        function startGame() {
            briefingScreen.classList.add('hidden');
            gameActive = true;
            document.body.focus();
            loginButton.textContent = "Login";
            
            // Ensure resize is triggered to set correct bounds
            resizeGame(); 
            
            requestAnimationFrame(gameLoop);
            updateTracker();
            dialogueContentEl.textContent = IDLE_DIALOGUE;
        }

        function triggerGameOver(reason) {
            gameActive = false;
            interactionActive = true;
            isModalVisible = true;
            gameOverModal.classList.remove('hidden');
            document.getElementById('game-over-modal').querySelector('#modal-concept').textContent = reason;
        }

        // --- Drawing Functions ---
        function drawTree(targetCtx, tx, ty, tw, th, cr, cc) {
            targetCtx.fillStyle = '#854d0e';
            targetCtx.fillRect(tx - tw / 2, ty, tw, th);
            targetCtx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            targetCtx.shadowBlur = 4;
            targetCtx.fillStyle = cc;
            targetCtx.beginPath();
            targetCtx.arc(tx, ty, cr, 0, Math.PI * 2);
            targetCtx.fill();
            targetCtx.closePath();
            targetCtx.fillStyle = 'rgba(106, 168, 79, 0.8)';
            targetCtx.beginPath();
            targetCtx.arc(tx + cr * 0.1, ty - cr * 0.15, cr * 0.85, 0, Math.PI * 2);
            targetCtx.fill();
            targetCtx.closePath();
            targetCtx.shadowBlur = 0;
        }

        function drawBench(targetCtx, x, y, w, h, legs) {
            const plankColor = '#a0522d';
            const frameColor = '#4a4a4a';
            targetCtx.fillStyle = plankColor;
            targetCtx.strokeStyle = '#4a4a4a';
            targetCtx.lineWidth = 1;
            const plankHeight = 8;
            const backrestHeight = 15;
            
            targetCtx.fillRect(x + 5, y, w - 10, plankHeight);
            targetCtx.strokeRect(x + 5, y, w - 10, plankHeight);
            targetCtx.fillRect(x + 5, y + plankHeight + 2, w - 10, plankHeight);
            targetCtx.strokeRect(x + 5, y + plankHeight + 2, w - 10, plankHeight);
            targetCtx.fillRect(x, y + backrestHeight + 10, w, plankHeight);
            targetCtx.strokeRect(x, y + backrestHeight + 10, w, plankHeight);
            targetCtx.fillRect(x, y + backrestHeight + 10 + plankHeight + 2, w, plankHeight);
            targetCtx.strokeRect(x, y + backrestHeight + 10 + plankHeight + 2, w, plankHeight);
            
            targetCtx.fillStyle = frameColor;
            legs.forEach(pos => {
                targetCtx.fillRect(pos[0], pos[1] - h + backrestHeight, 5, h - backrestHeight);
            });
            targetCtx.fillRect(x, y + backrestHeight + 8, w, 2);
        }

        function drawCharacter(x, y, radius, color, isGuard = false, isCEO = false) {
            const bobOffset = gameActive && !interactionActive ? Math.sin(Date.now() / 200) * 2 : 0;
            y += bobOffset;

            const headRadius = radius * 0.7;
            const torsoHeight = radius * 2.2;
            let shoulderWidth = radius * 2.0; 
            const waistWidth = shoulderWidth * 0.7; 
            const shoulderPointY = y - torsoHeight;
            const neckGap = radius * 0.3; 
            const necklineDip = neckGap * 1.5; 

            const baseColor = color;
            let darkerColor = '#333333';

            if (typeof baseColor === 'string' && baseColor.startsWith('#')) {
                try {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    darkerColor = `rgba(${Math.floor(r * 0.8)}, ${Math.floor(g * 0.8)}, ${Math.floor(b * 0.8)}, 1)`;
                } catch (e) {}
            }

            const torsoBottomY = y; 
            const headCenterY = shoulderPointY - headRadius - neckGap;

            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 4;
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#1f2937';
            ctx.fillStyle = baseColor;

            ctx.beginPath();
            ctx.moveTo(x + waistWidth / 2, torsoBottomY);
            ctx.bezierCurveTo(x + waistWidth / 2 + 5, torsoBottomY - torsoHeight * 0.5, x + shoulderWidth / 2, shoulderPointY + (torsoHeight * 0.2), x + shoulderWidth / 2, shoulderPointY);
            ctx.quadraticCurveTo(x, shoulderPointY - necklineDip, x - shoulderWidth / 2, shoulderPointY);
            ctx.bezierCurveTo(x - shoulderWidth / 2, shoulderPointY + (torsoHeight * 0.2), x - waistWidth / 2 - 5, torsoBottomY - torsoHeight * 0.5, x - waistWidth / 2, torsoBottomY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = darkerColor;
            ctx.globalAlpha = 0.3;
            ctx.fill();
            ctx.globalAlpha = 1.0; 

            ctx.shadowBlur = 4; 
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.arc(x, headCenterY, headRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.closePath();
            
            ctx.shadowBlur = 0; 
        }

        // UPGRADE 4: Textured Background (Procedural Noise)
        function drawGrassTexture(targetCtx, playableHeight) {
            targetCtx.fillStyle = '#4CAF50'; 
            targetCtx.fillRect(0, 0, GAME_WIDTH, playableHeight);

            // Simple Noise Generation for texture
            const noiseCanvas = document.createElement('canvas');
            noiseCanvas.width = 100;
            noiseCanvas.height = 100;
            const noiseCtx = noiseCanvas.getContext('2d');
            
            for(let i=0; i<300; i++) {
                noiseCtx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.05)';
                noiseCtx.fillRect(Math.random()*100, Math.random()*100, 2, 2);
            }
            
            const pattern = targetCtx.createPattern(noiseCanvas, 'repeat');
            targetCtx.fillStyle = pattern;
            targetCtx.fillRect(0, 0, GAME_WIDTH, playableHeight);

            function seededRandom(seed) {
                let x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            }
            let seed = 12345;
            targetCtx.fillStyle = 'rgba(20, 80, 20, 0.2)'; 
            for (let i = 0; i < 500; i++) {
                const x = seededRandom(seed++) * GAME_WIDTH;
                const y = seededRandom(seed++) * playableHeight;
                targetCtx.fillRect(x, y, 2, 4);
            }
            const flowerColors = ['#fca5a5', '#fcd34d', '#93c5fd', '#f472b6'];
            for (let i = 0; i < 20; i++) {
                targetCtx.fillStyle = flowerColors[i % flowerColors.length];
                targetCtx.beginPath();
                targetCtx.arc(seededRandom(seed++) * GAME_WIDTH, seededRandom(seed++) * playableHeight, 4, 0, Math.PI * 2);
                targetCtx.fill();
            }
        }

        function updateLayout() {
            const pathW = Math.min(300, GAME_WIDTH / 3);
            const pathX = GAME_WIDTH / 2 - pathW / 2;
            const rightEdge = GAME_WIDTH * 0.95;

            scenery = [
                // Left side scenery
                { type: 'tree', tx: GAME_WIDTH * 0.1, ty: PLAYABLE_AREA_BOTTOM * 0.8, tw: 20, th: 50, cr: 40, cc: '#38761d' },
                { type: 'tree', tx: GAME_WIDTH * 0.05, ty: PLAYABLE_AREA_BOTTOM * 0.4, tw: 20, th: 50, cr: 45, cc: '#38761d' },
                { type: 'bench', color: '#854d0e', x: GAME_WIDTH * 0.15, y: 100, w: 100, h: 40, legs: [[GAME_WIDTH * 0.15 + 5, 140], [GAME_WIDTH * 0.15 + 85, 140]] },
                { type: 'cooler', color: '#90caf9', borderColor: '#1e3a8a', x: GAME_WIDTH * 0.05, y: 250, w: 30, h: 60 },
                
                // Right side scenery
                { type: 'tree', tx: GAME_WIDTH * 0.9, ty: PLAYABLE_AREA_BOTTOM * 0.6, tw: 20, th: 50, cr: 40, cc: '#6aa84f' },
                { type: 'tree', tx: GAME_WIDTH * 0.95, ty: PLAYABLE_AREA_BOTTOM * 0.35, tw: 20, th: 50, cr: 45, cc: '#38761d' }, 
                { type: 'bench', color: '#854d0e', x: GAME_WIDTH * 0.75, y: 350, w: 100, h: 40, legs: [[GAME_WIDTH * 0.75 + 5, 390], [GAME_WIDTH * 0.75 + 85, 390]] },
            ];

            // Update Monument Position
            propsData['Monument'].x = GAME_WIDTH * 0.80;
            propsData['Monument'].y = 60;
        }

        function drawScenery(targetCtx) {
            const playableHeight = PLAYABLE_AREA_BOTTOM;
            drawGrassTexture(targetCtx, playableHeight);

            const pathW = Math.min(300, GAME_WIDTH / 3); 
            const pathX = GAME_WIDTH / 2 - pathW / 2;
            const gradient = targetCtx.createLinearGradient(pathX, 0, pathX + pathW, 0);
            gradient.addColorStop(0, '#8b756c');
            gradient.addColorStop(0.5, '#7a6a61');
            gradient.addColorStop(1, '#8b756c');
            targetCtx.fillStyle = gradient;
            targetCtx.strokeStyle = '#6e5e55';
            targetCtx.lineWidth = 6;
            targetCtx.fillRect(pathX, 0, pathW, playableHeight);
            targetCtx.strokeRect(pathX, 0, pathW, playableHeight);

            function seededRandom(seed) { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); }
            let seed = 54321;
            targetCtx.fillStyle = 'rgba(40, 40, 40, 0.4)';
            for (let i = 0; i < 500; i++) {
                targetCtx.beginPath();
                targetCtx.arc(pathX + seededRandom(seed++) * pathW, seededRandom(seed++) * playableHeight, 1, 0, Math.PI * 2);
                targetCtx.fill();
            }

            scenery.forEach(item => {
                if (item.type === 'tree') drawTree(targetCtx, item.tx, item.ty, item.tw, item.th, item.cr, item.cc);
                else if (item.type === 'bench') drawBench(targetCtx, item.x, item.y, item.w, item.h, item.legs);
                else if (item.type === 'cooler') {
                    targetCtx.fillStyle = item.color;
                    targetCtx.fillRect(item.x, item.y, item.w, item.h);
                    targetCtx.strokeStyle = item.borderColor;
                    targetCtx.lineWidth = 2;
                    targetCtx.strokeRect(item.x, item.y, item.w, item.h);
                }
            });
            
            // Draw Props
            for (const key in propsData) {
                const prop = propsData[key];
                targetCtx.fillStyle = prop.color;
                targetCtx.fillRect(prop.x, prop.y, prop.width, prop.height);
                
                // UPDATE: Blank Monument (No "20.." text)
            }
        }

        function preRenderStaticBackground() { 
            backgroundCanvas.width = GAME_WIDTH;
            backgroundCanvas.height = PLAYABLE_AREA_BOTTOM;
            drawScenery(backgroundCtx); 
        }

        function render() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            const playableHeight = PLAYABLE_AREA_BOTTOM;
            ctx.drawImage(backgroundCanvas, 0, 0);

            if (interactionActive && activeNPCKey) {
                // Dialogue Mode: Dim background
                ctx.fillStyle = 'rgba(15, 23, 42, 0.85)';
                ctx.fillRect(0, 0, GAME_WIDTH, playableHeight);
                
                // Check if activeNPCKey is a prop or NPC
                const isProp = propsData[activeNPCKey] !== undefined;
                const entity = isProp ? propsData[activeNPCKey] : npcsData[activeNPCKey];
                
                if (!isProp) {
                    // FIX: Scale portrait dynamically to fit screen
                    const availableHeight = playableHeight - 20; 
                    const maxPortraitRadius = availableHeight / 3.5; // Based on height ratio (approx 3.5r total height)
                    const portraitRadius = Math.min(100, maxPortraitRadius); // Cap at 100px

                    const portraitX = GAME_WIDTH * 0.2; 
                    // FIX: Draw from bottom of playable area
                    const characterBaseY = playableHeight; 
                    
                    // Draw Spotlighting behind portrait
                    const gradient = ctx.createRadialGradient(portraitX, characterBaseY - 150, 50, portraitX, characterBaseY - 150, 250);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, GAME_WIDTH / 2, playableHeight);

                    drawCharacter(portraitX, characterBaseY, portraitRadius, entity.color, entity.isGuard, activeNPCKey === 'Orange (CEO)');
                } else {
                    // Draw prop preview if needed, or just text
                }
            } else {
                // Standard Game View
                for (const key in npcsData) {
                    const npc = npcsData[key];
                    drawCharacter(npc.x, npc.y + npcRadius, npcRadius, npc.color, npc.isGuard, key === 'Orange (CEO)'); 
                }
                drawCharacter(player.x, player.y + playerRadius, playerRadius, '#ef4444', false, false); 
                
                // UPGRADE 3: Vignette / Lighting
                const gradient = ctx.createRadialGradient(GAME_WIDTH/2, playableHeight/2, 100, GAME_WIDTH/2, playableHeight/2, Math.max(GAME_WIDTH, playableHeight));
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(15, 23, 42, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, playableHeight);
            }
        }

        // --- Core Logic ---
        const vulnerabilityReport = {
            'pet_name': { weakness: "Password based on pet name ('Sparky').", fix: "Enforce password complexity, multi-factor authentication (MFA), and strictly prohibit public biographical data in security answers." },
            'founding_year': { weakness: "Founding year ('2008') used in passwords.", fix: "Block common numeric patterns (years, dates) in password policy. Implement stronger two-factor authentication." },
            'mascot_name': { weakness: "Company mascot ('Buster the Beaver') used as a password component.", fix: "Educate employees on social engineering risks. Audit public-facing corporate culture (mascots, slogans) to ensure they aren't secret knowledge." }
        };

        function getFinalReport() {
            let reportHtml = '<h3 class="text-red-700 mb-3">VULNERABILITY REPORT</h3><ul class="list-disc ml-5 mb-6 text-left">';
            let fixRecommendations = '<h3 class="text-green-700 mb-3">CYBERSECURITY RECOMMENDATIONS</h3><ul class="list-disc ml-5 text-left">';
            let factsCount = 0;
            for (const key in collectedFacts) {
                if (vulnerabilityReport[key]) {
                    const factName = factDefinitions[key];
                    const factValue = collectedFacts[key].name;
                    const report = vulnerabilityReport[key];
                    reportHtml += `<li><strong>${factName}: ${factValue}</strong> (Weakness: ${report.weakness})</li>`;
                    fixRecommendations += `<li>${report.fix}</li>`;
                    factsCount++;
                }
            }
            reportHtml += '</ul>'; fixRecommendations += '</ul>';
            return factsCount === FACTS_REQUIRED ? reportHtml + fixRecommendations : '<p>Audit incomplete. No final report generated.</p>';
        }

        // NEW FUNCTION: Show Final End Screen
        function showFinalEndScreen() {
            infoModal.classList.add('hidden');
            isModalVisible = true;
            finalScreenModal.classList.remove('hidden');
        }

        // NEW FUNCTION: Show Educational Slides (Modified ending)
        function showEducationalContent() {
            if (currentEduIndex < educationalContent.length) {
                const content = educationalContent[currentEduIndex];
                currentEduIndex++;
                
                modalTitle.textContent = content.title;
                modalConcept.textContent = content.concept; 
                modalExplanation.innerHTML = content.body; // Use innerHTML for image tags
                finalReportSection.classList.add('hidden'); // Hide report if shown
                infoModal.classList.remove('hidden');
                isModalVisible = true;

                // Custom button for next/close
                const modalButton = document.querySelector('#info-modal button[class*="bg-blue-600"]');
                if (currentEduIndex < educationalContent.length) {
                    modalButton.textContent = "Next: Core Concept";
                    modalButton.onclick = showEducationalContent;
                } else {
                    // This is the LAST slide, button leads to the final screen
                    modalButton.textContent = "View Final Summary";
                    modalButton.onclick = showFinalEndScreen; 
                }
            } else {
                // Fail-safe, should not be hit if buttons are set correctly
                showFinalEndScreen();
            }
        }

        function checkPassword() {
            playClick();
            const guess = passwordInput.value.trim();
            if (Object.keys(collectedFacts).length !== FACTS_REQUIRED) {
                showModal("ATTENTION: Audit Incomplete", "You must collect all 3 key password components before attempting to breach the system.", "Go talk to more people and check your tracker!");
                return;
            }
            // Removed: Report display on check
            finalReportSection.classList.add('hidden');

            if (guess === TARGET_PASSWORD) {
                playSuccess();
                // UPDATED SUCCESS MODAL CALL: First, show the immediate success and report.
                modalTitle.textContent = "CRITICAL VULNERABILITY DEMONSTRATED!";
                modalConcept.textContent = `Login Successful. Password: ${guess}`;
                modalExplanation.textContent = "The system has been successfully breached by aggregating public information. Review the report below, then click 'Next' to explore the key OSINT concepts you used.";
                
                // Show report ONLY on success
                finalReportSection.innerHTML = getFinalReport();
                finalReportSection.classList.remove('hidden');
                
                infoModal.classList.remove('hidden');
                isModalVisible = true;
                gameActive = false;

                // Custom button for the success screen, leading to educational slides
                const modalButton = document.querySelector('#info-modal button[class*="bg-blue-600"]');
                modalButton.textContent = "Next: Start Educational Report";
                modalButton.onclick = () => {
                    finalReportSection.classList.add('hidden'); // Hide report for the next slide
                    currentEduIndex = 0; // Reset index to 0
                    currentEduIndex++; // Advance index to 1 so the first call of showEducationalContent loads index 0
                    showEducationalContent(); // Immediately call the first slide
                };
            } else {
                loginAttempts--;
                if (loginAttempts <= 0) {
                    triggerGameOver("Failed to guess the password after three attempts. Access denied.");
                    return;
                }
                playWarning();
                // User requested change: "it should just say password incorrect"
                showModal("LOGIN FAILED", "Password Incorrect", `You have ${loginAttempts} attempt(s) left.`);
                loginButton.textContent = `${loginAttempts} attempts left`;
                loginButton.style.backgroundColor = '#ef4444';
                passwordInput.blur();
            }
        }

        function showModal(title, concept, explanation) {
            modalTitle.textContent = title;
            modalConcept.textContent = concept;
            modalExplanation.textContent = explanation;
            finalReportSection.classList.add('hidden'); // Always hide the final report for generic modals
            infoModal.classList.remove('hidden');
            isModalVisible = true;
            
            // Reset button to default for normal modals
            const modalButton = document.querySelector('#info-modal button[class*="bg-blue-600"]');
            modalButton.textContent = "Acknowledge & Continue";
            modalButton.onclick = continueGame;
        }

        function updateTracker() {
            let factsCount = 0;
            for (const key in trackerElements) {
                const element = trackerElements[key];
                element.classList.remove('collected', 'missing');
                if (collectedFacts[key]) {
                    element.textContent = `${Object.keys(trackerElements).indexOf(key) + 1}.) ${factDefinitions[key]}: ${collectedFacts[key].name}`;
                    element.classList.add('collected');
                    factsCount++;
                } else {
                    element.textContent = `${Object.keys(trackerElements).indexOf(key) + 1}.) ???`;
                    element.classList.add('missing');
                }
            }
            if (factsCount === FACTS_REQUIRED) {
                 if (!document.getElementById('audit-button')) {
                    const auditButton = document.createElement('button');
                    auditButton.id = 'audit-button';
                    auditButton.textContent = 'All Facts Collected! Attempt Login Below.';
                    auditButton.onclick = () => {
                        dialogueContentEl.textContent = "All facts collected. Enter your combined password guess in the panel below!";
                    };
                    choiceButtons.appendChild(auditButton);
                    dialogueContentEl.textContent = "You have collected all three key facts. The Audit is complete, now attempt the login!";
                }
                // Show hint
                passwordHintEl.textContent = "Hint: Combine the intel to guess the password: Pet + Year + Mascot";
                passwordHintEl.classList.remove('hidden');
            }
        }

        function loadScenario(scenario, npcKey) {
            // Check if speaker is a prop or NPC
            const isProp = propsData[npcKey] !== undefined;
            const entity = isProp ? propsData[npcKey] : npcsData[npcKey];

            speakerNameEl.textContent = npcKey;
            speakerNameEl.style.backgroundColor = entity ? entity.color : '#94a3b8'; 
            speakerNameEl.style.display = 'inline-block';
            
            typeText(dialogueContentEl, scenario.dialogue); 
            
            choiceButtons.innerHTML = ''; 
            if (!scenario.isGuard && !scenario.action && npcKey !== 'Purple' && npcKey !== 'Green' && npcKey !== 'Yellow' && npcKey !== 'Cyan') {
                if (scenario.choices[0]?.info && collectedFacts[scenario.choices[0].info.key]) {
                    dialogueContentEl.textContent = `(You already collected this data point. The fact was: ${collectedFacts[scenario.choices[0].info.key].name})`;
                    const button = document.createElement('button');
                    button.textContent = "Acknowledge and Move On";
                    button.onclick = continueGame;
                    choiceButtons.appendChild(button);
                    return;
                }
            }

            scenario.choices.forEach(choice => {
                const button = document.createElement('button');
                button.textContent = choice.text;
                button.onclick = () => handleChoice(choice, scenario, npcKey);
                choiceButtons.appendChild(button);
            });
            
            // FIX: Ensure buttons are visible after load
            choiceButtons.style.display = 'flex';
        }

        function handleChoice(choice, scenario, npcKey) {
            playClick();
            
            // SAFETY: Clear typing immediately
            if(typingInterval) clearInterval(typingInterval);
            
            choiceButtons.style.display = 'none'; 
            const riskChange = choice.risk !== undefined ? choice.risk : (choice.secure ? -1 : 15);
            updateSuspicion(riskChange);

            // NEW GUARD LOGIC: Immediate Game Over if you admit to not being an employee
            if (choice.action === 'guard_fail_kickout') {
                triggerGameOver("Guard: This is a company picnic. You are not an employee and must leave immediately.");
                return;
            }
            
            // Handle neutral guard passes (from choosing 'Yes, I am' or 'Yes, I'm staff')
            if (scenario.isGuard && choice.action === 'guard_pass') {
                showModal("Guard Interaction", "They accepted your presence.", `They seem satisfied with your brief answer and didn't press further.`);
                return;
            }

            if (choice.action === 'purple_step2') { loadScenario(getScenario('Purple_step2'), npcKey); return; }
            
            if (choice.action === 'monument_hint') {
                gameHints['uses_year_in_password'] = true;
                showModal("NEW LEAD ACQUIRED", "Incomplete Date", "The monument is worn, but the CEO must know the exact year. I should ask him 'When did the company start?'.");
                updateTracker();
                return;
            }

            if (choice.action === 'cyan_hint') {
                gameHints['uses_year_in_password'] = true;
                // Changed to modal as per user request for internal thoughts
                showModal("NEW LEAD ACQUIRED", "Founding Year Strategy", "I heard the boss uses his company's founding year. I should ask the CEO about this.");
                updateTracker();
                return;
            }

            if (choice.action === 'yellow_hint') {
                gameHints['uses_mascot_in_password'] = true;
                // Fixed: Use modal instead of dialogue text to prevent freezing and logic mismatch
                showModal("NEW LEAD ACQUIRED", "Mascot Name Strategy", "That confirms the CEO puts the mascot name into his security data. I should talk to someone who knows the name.");
                updateTracker();
                return;
            }

            if (choice.secure && choice.info) {
                collectedFacts[choice.info.key] = choice.info;
                showModal("⭐ DATA COLLECTED! ⭐", `Fact Recorded: ${factDefinitions[choice.info.key]}: ${choice.info.name}`, "This piece of public information is now aggregated in your audit report.");
            } else if (choice.secure) {
                showModal("Neutral Interaction", "You kept the conversation subtle. (+Trust)", "No useful data was gathered, but you avoided arousing suspicion.");
            } else {
                showModal("RISK ALERT: Too Probing", "Your question could draw suspicion from alert employees. (+Suspicion)", `You risked exposing your intent. Focus on subtle information gathering.`);
            }
            finalReportSection.classList.add('hidden');
            updateTracker();
        }

        function createAcknowledgeButton() {
            choiceButtons.innerHTML = '';
            const proceedButton = document.createElement('button');
            proceedButton.textContent = "Acknowledge";
            proceedButton.onclick = continueGame;
            choiceButtons.appendChild(proceedButton);
        }

        function getScenario(npcKey) {
            // Simple props handling
            if (propsData[npcKey]) return propsData[npcKey];

            // Logic for static scenarios
            const staticScenarios = {
                'Purple': { dialogue: npcsData['Purple'].dialogue, choices: [{ text: "A: Engage in small talk about the dog.", secure: true, action: 'purple_step2', risk: -5 }] },
                'Purple_step2': { dialogue: "Oh, his name is Sparky! He's just the cutest. My husband says he's part of the family, even in his work passwords!", choices: [{ text: "Acknowledge and log the pet name.", secure: true, info: { key: 'pet_name', name: "Sparky" }, risk: -2 }] },
                // Uses initial dialogue from npcsData
                'Orange (CEO)': { dialogue: npcsData['Orange (CEO)'].dialogue, choices: npcsData['Orange (CEO)'].choices },
                'Green': { dialogue: npcsData['Green'].dialogue, choices: [{ text: "A: Jot down the mascot's name.", secure: true, info: { key: 'mascot_name', name: "Buster the Beaver" } }] },
                'Yellow': { isHint: true, dialogue: npcsData['Yellow'].dialogue, choices: [{ text: "A: Acknowledge the comment.", secure: true, action: 'yellow_hint', info: { key: 'uses_mascot_in_password', name: "Mascot Hint" }, risk: -2 }] },
                'Violet': { dialogue: npcsData['Violet'].dialogue, choices: npcsData['Violet'].choices },
                'Pink': { dialogue: npcsData['Pink'].dialogue, choices: npcsData['Pink'].choices },
                'Gray': { dialogue: npcsData['Gray'].dialogue, choices: npcsData['Gray'].choices },
                'Magenta': { dialogue: npcsData['Magenta'].dialogue, choices: npcsData['Magenta'].choices },
                'Lime': { dialogue: npcsData['Lime'].dialogue, choices: npcsData['Lime'].choices },
                'Amber': { dialogue: npcsData['Amber'].dialogue, choices: npcsData['Amber'].choices },
                'Cyan': { isHint: true, dialogue: npcsData['Cyan'].dialogue, choices: [{ text: "A: Jot down the tip.", secure: true, action: 'cyan_hint', info: { key: 'uses_year_in_password', name: "Founding Year Hint" }, risk: -2 }] },
                // UPDATED GUARD DIALOGUE/CHOICES (Neutralizes security threat)
                'Blue Guard 1': { isGuard: true, dialogue: npcsData['Blue Guard 1'].dialogue, choices: npcsData['Blue Guard 1'].choices },
                'Blue Guard 2': { isGuard: true, dialogue: npcsData['Blue Guard 2'].dialogue, choices: npcsData['Blue Guard 2'].choices },
            };
            let scenario = staticScenarios[npcKey];
            
            // Dynamic Overrides
            if (npcKey === 'Green') {
                if (collectedFacts['mascot_name']) scenario = { dialogue: "Green nods. 'Buster's the best, he was just over by the cake table.'", choices: [{ text: "Acknowledge and Move On", secure: true, risk: -2 }] };
                else if (gameHints['uses_mascot_in_password']) scenario = { dialogue: "Green: The mascot? Oh yeah, Buster the Beaver! Why do you ask?", choices: [{ text: "A: Ask for the mascot's name.", secure: true, info: { key: 'mascot_name', name: "Buster the Beaver" }, risk: 10 }, { text: "B: Change the subject.", secure: true, risk: -5 }] };
            }
            if (npcKey.includes('Guard')) return { isGuard: true, dialogue: npcsData[npcKey].dialogue, choices: npcsData[npcKey].choices }; // Use the simplified guard choices
            if (npcKey === 'Orange (CEO)') {
                if (collectedFacts['founding_year']) scenario = { dialogue: "The CEO smiles genuinely. 'It's a great event, and our future looks bright.'", choices: [{ text: "Acknowledge and Move On", secure: true, risk: -2 }] };
                else if (gameHints['uses_year_in_password']) {
                    // Keep risky choice available even with hint active, but add key intel option
                    scenario = { 
                        dialogue: "The CEO smiles, 'Yes, it's nice to relax. Did you need something specific?'", 
                        choices: [
                            { text: "A: Ask casually: 'When did the company start?'", secure: true, info: { key: 'founding_year', name: "2008" }, risk: 10 }, 
                            { text: "B: Discuss the good music.", secure: true, risk: -5 },
                            { text: "C: Ask for his login credentials directly.", secure: false, risk: 80 }
                        ] 
                    };
                }
            }
            return scenario;
        }

        function continueGame() {
            // This function is for closing generic modals and resuming movement.
            if (isModalVisible) {
                infoModal.classList.add('hidden');
                isModalVisible = false; 
            }

            if (!gameActive) return;

            gameActive = true;
            choiceButtons.style.display = 'flex'; 
            choiceButtons.innerHTML = ''; 
            speakerNameEl.style.display = 'none';
            activeNPCKey = null;
            dialogueContentEl.textContent = IDLE_DIALOGUE;
            if(typingInterval) clearInterval(typingInterval);
            interactionActive = false;
            canInteract = false;      
            // Force focus back to body so movement keys work
            document.body.focus();
            setTimeout(() => { canInteract = true; }, INTERACTION_COOLDOWN);
        }

        document.addEventListener('keydown', (e) => {
            if (!gameActive || isModalVisible || interactionActive) return;
            const key = e.key.toLowerCase();
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) keysPressed[key] = true;
        });
        document.addEventListener('keyup', (e) => {
            if (!gameActive || isModalVisible || interactionActive) return;
            const key = e.key.toLowerCase();
            delete keysPressed[key];
        });

        function resizeGame() {
            const container = document.getElementById('game-container');
            GAME_WIDTH = container.clientWidth;
            GAME_HEIGHT = container.clientHeight;
            
            // Ensure canvas element matches display size
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            
            // Adjust playable area so players don't walk behind the text box
            // Reduced offset for smaller text box
            PLAYABLE_AREA_BOTTOM = GAME_HEIGHT - 120;
            
            // Re-calculate dynamic positions
            updateLayout();

            // Re-render background for new dimensions
            preRenderStaticBackground();
            
            // Optionally reset player if out of bounds
            if (player.x > GAME_WIDTH) player.x = GAME_WIDTH - 50;
            if (player.y > PLAYABLE_AREA_BOTTOM) player.y = PLAYABLE_AREA_BOTTOM - 50;
        }

        window.addEventListener('resize', resizeGame);

        function updatePlayerPosition(deltaTime) {
            if (!gameActive || interactionActive || isModalVisible) return;
            let dx = 0, dy = 0;
            if (keysPressed['arrowup'] || keysPressed['w']) dy -= 1;
            if (keysPressed['arrowdown'] || keysPressed['s']) dy += 1;
            if (keysPressed['arrowleft'] || keysPressed['a']) dx -= 1;
            if (keysPressed['arrowright'] || keysPressed['d']) dx += 1;
            if (dx === 0 && dy === 0) return;
            if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
            let newX = player.x + dx * playerSpeed * deltaTime;
            let newY = player.y + dy * playerSpeed * deltaTime;
            
            // UPDATED: Strict Boundaries
            // Character is drawn UP from x,y. y is at the feet.
            // Top bound: needs to account for character height (approx 3.5 * radius)
            const characterHeight = 3.5 * playerRadius;
            const topBound = characterHeight + 20; // Small buffer from top
            const bottomBound = PLAYABLE_AREA_BOTTOM;
            const sideBound = playerRadius + 5;

            newX = Math.max(sideBound, Math.min(GAME_WIDTH - sideBound, newX));
            newY = Math.max(topBound, Math.min(bottomBound - 5, newY));

            player.x = newX; player.y = newY;
            checkCollisions();
        }

        function updateNPCs(deltaTime) {
            if (interactionActive || !gameActive) return;
            
            // UPDATED: Strict Boundaries for NPCs
            const characterHeight = 3.5 * npcRadius;
            const topBound = characterHeight + 20;
            const bottomBound = PLAYABLE_AREA_BOTTOM;
            const sideBound = npcRadius + 5;

            for (const key in npcsData) {
                const npc = npcsData[key];
                if (npc.isGuard || !npc.vx) continue;
                npc.moveTimer -= deltaTime;
                if (npc.moveTimer <= 0) {
                    npc.vx = (Math.random() * 2 - 1) * npcWanderSpeed * (1 + suspicion / 200);
                    npc.vy = (Math.random() * 2 - 1) * npcWanderSpeed * (1 + suspicion / 200);
                    npc.moveTimer = 2 + Math.random() * 3;
                }
                let newX = npc.x + npc.vx * deltaTime;
                let newY = npc.y + npc.vy * deltaTime;
                
                if (newX < sideBound || newX > GAME_WIDTH - sideBound) { 
                    npc.vx *= -1; 
                    newX = Math.max(sideBound, Math.min(GAME_WIDTH - sideBound, newX)); 
                }
                if (newY < topBound || newY > bottomBound - 5) { 
                    npc.vy *= -1; 
                    newY = Math.max(topBound, Math.min(bottomBound - 5, newY)); 
                }
                
                npc.x = newX; npc.y = newY;
            }
        }

        function checkCollisions() {
            if (!gameActive || interactionActive || !canInteract || isModalVisible) return; 
            
            // Check NPCs
            for (const key in npcsData) {
                const npc = npcsData[key];
                const distance = Math.sqrt(Math.pow(player.x - npc.x, 2) + Math.pow(player.y - npc.y, 2));
                if (distance < playerRadius + npcRadius + 5) { startInteraction(key); return; }
            }

            // Check Props
            for (const key in propsData) {
                const prop = propsData[key];
                // Simple distance check to center of prop
                const dist = Math.sqrt(Math.pow(player.x - (prop.x + prop.width/2), 2) + Math.pow(player.y - (prop.y + prop.height/2), 2));
                if (dist < playerRadius + 40) { // 40 is approx interaction radius
                    startInteraction(key); 
                    return; 
                }
            }
        }
        
        function startInteraction(npcKey) {
            keysPressed = {}; 
            interactionActive = true; 
            activeNPCKey = npcKey;
            const scenario = getScenario(npcKey);
            if (scenario) loadScenario(scenario, npcKey); 
        }
        
        function gameLoop(currentTime) {
            if (lastTime === 0) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000; 
            if (gameActive) { updatePlayerPosition(deltaTime); updateNPCs(deltaTime); render(); }
            lastTime = currentTime; 
            requestAnimationFrame(gameLoop);
        }

        window.onload = function() {
            const load = document.getElementById("loading-screen");
            if(load) {
                setTimeout(() => {
                    load.style.opacity = 0;
                    setTimeout(() => load.remove(), 700);
                }, 1000);
            }
            player.x = window.innerWidth / 2;
            player.y = 150;
            loginButton.textContent = "Login"; // Initialize button text
            document.body.focus();
            updateTracker(); 
            
            // Ensure resizeGame is called to set initial bounds and render bg
            resizeGame();
            
            // Start loop immediately but input blocked until 'Start' clicked
            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>